/* Copyright (c) 2011 Danish Maritime Authority
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
package dk.dma.msinm.user;

import dk.dma.msinm.common.mail.MailService;
import dk.dma.msinm.common.service.BaseService;
import dk.dma.msinm.user.security.JbossJaasCacheFlusher;
import dk.dma.msinm.user.security.oath.OAuthLogin;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;

import javax.ejb.Stateless;
import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Business interface for managing User entities
 */
@Stateless
public class UserService extends BaseService {

    @Inject
    private Logger log;

    @Inject
    private MailService mailService;

    @Inject
    private JbossJaasCacheFlusher jbossJaasCacheFlusher;

    /**
     * Looks up an {@code OAuthLogin} for the given provider and id
     *
     * @param provider the provide
     * @param id the id
     * @return the matching entity or null
     */
    public OAuthLogin findByProvider(String provider, String id) {
        try {
            return em.createNamedQuery("OAuthLogin:findLoginByProvider", OAuthLogin.class)
                .setParameter("provider", provider)
                .setParameter("providerId", id)
                .getSingleResult();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Looks up an {@code OAuthLogin} for the given provider and access token
     *
     * @param provider the provide
     * @param accessToken the access token
     * @return the matching entity or null
     */
    public OAuthLogin findByAccessToken(String provider, String accessToken) {
        try {
            return em.createNamedQuery("OAuthLogin:findLoginByAccessToken", OAuthLogin.class)
                .setParameter("provider", provider)
                .setParameter("accessToken", accessToken)
                .getSingleResult();
        } catch (Exception e) {
            return null;
        }
    }


    /**
     * Looks up the {@code User} with the given id and preloads the roles
     *
     * @param id the id
     * @return the user or null
     */
    public User findById(Integer id) {
        try {
            return em.createNamedQuery("User.findById", User.class)
                    .setParameter("id", id)
                    .getSingleResult();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Looks up the {@code User} with the given email addressand preloads the roles
     *
     * @param email the email
     * @return the user or null
     */
    public User findByEmail(String email) {
        try {
            return em.createNamedQuery("User.findByEmail", User.class)
                    .setParameter("email", email)
                    .getSingleResult();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * First step of setting a new password.
     * A reset-password token is generated and an email sent to the user
     * with a link to reset the password.
     * @param email the email address
     */
    public void resetPassword(String email) throws Exception {
        User user = findByEmail(email);
        if (user == null) {
            throw new Exception("Invalid email " + email);
        }

        user.setResetPasswordToken(UUID.randomUUID().toString());
        saveEntity(user);

        Map<String, Object> data = new HashMap<>();
        data.put("token", user.getResetPasswordToken());
        data.put("name", user.getName());
        data.put("email", user.getEmail());

        mailService.sendMail("reset-password.ftl", data, "Reset Password", email);
    }

    /**
     * Second step of setting a new password.
     * The used submits the token generated by calling {@code resetPassword()}
     * along with the new password.
     *
     * @param email the email address
     *
     */
    public void updatePassword(String email, String password, String token) throws Exception {
        User user = findByEmail(email);
        if (user == null) {
            throw new Exception("Invalid email " + email);
        }

        if (!token.equals(user.getResetPasswordToken())) {
            throw new Exception("Invalid token " + token);
        }

        // TODO: More rigid password rules
        if (StringUtils.isBlank(password)) {
            throw new Exception("Invalid blank password");
        }

        // TODO: email used as salt for now
        user.getPassword().setPassword(password, email);

        // Reset the password token, so the same mail cannot be used again...
        user.setResetPasswordToken(null);

        // Persist the user entity
        saveEntity(user);

        // Flush the jboss JAAS cache
        jbossJaasCacheFlusher.flushJaasCache(email);
    }
}
